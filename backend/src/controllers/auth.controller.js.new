const { 
  tokenService, 
  passwordService, 
  permissionService,
  auditService 
} = require('../services/auth.service');
const userService = require('../services/user.service');
const { pool } = require('../config/database');
const { logger } = require('../utils/logger');
const { createError } = require('../utils/error.util');
const config = require('../config/config');

/**
 * @swagger
 * tags:
 *   name: Authentication
 *   description: User authentication and account management
 */

/**
 * @swagger
 * /auth/register/student:
 *   post:
 *     summary: Register a new student
 *     tags: [Authentication]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - email
 *               - password
 *               - identifier
 *               - firstName
 *               - lastName
 *             properties:
 *               email:
 *                 type: string
 *                 format: email
 *               password:
 *                 type: string
 *                 minLength: 6
 *               identifier:
 *                 type: string
 *               firstName:
 *                 type: string
 *               lastName:
 *                 type: string
 *               yearLevel:
 *                 type: string
 *               major:
 *                 type: string
 *     responses:
 *       201:
 *         description: Student registered successfully
 *       400:
 *         $ref: '#/components/responses/ValidationError'
 *       409:
 *         description: User with this email or student ID already exists
 *       500:
 *         $ref: '#/components/responses/ServerError'
 */
exports.registerStudent = async (req, res, next) => {
  try {
    const userData = req.body;
    
    // Create user with student role
    const user = await userService.createUser(userData, 'student');
    
    // Log successful registration
    auditService.logAuthEvent('register', {
      userId: user.id,
      email: user.email,
      success: true,
      ipAddress: req.ip,
      userAgent: req.get('User-Agent')
    }).catch(err => logger.error('Failed to log registration event:', err));
    
    logger.info(`Student registered: ${user.email}`);
    
    return res.created(
      { userId: user.id },
      'Student registered successfully. Please check your email to verify your account.'
    );
  } catch (error) {
    // Log failed registration attempt
    if (req.body && req.body.email) {
      auditService.logAuthEvent('register', {
        email: req.body.email,
        success: false,
        ipAddress: req.ip,
        userAgent: req.get('User-Agent'),
        reason: error.message
      }).catch(err => logger.error('Failed to log registration failure:', err));
    }
    
    logger.error('Student registration error:', error);
    next(error);
  }
};

/**
 * @swagger
 * /auth/register/teacher:
 *   post:
 *     summary: Register a new teacher
 *     tags: [Authentication]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - email
 *               - password
 *               - identifier
 *               - firstName
 *               - lastName
 *             properties:
 *               email:
 *                 type: string
 *                 format: email
 *               password:
 *                 type: string
 *                 minLength: 6
 *               identifier:
 *                 type: string
 *               firstName:
 *                 type: string
 *               lastName:
 *                 type: string
 *               department:
 *                 type: string
 *               title:
 *                 type: string
 *     responses:
 *       201:
 *         description: Teacher registered successfully
 *       400:
 *         $ref: '#/components/responses/ValidationError'
 *       409:
 *         description: User with this email or staff ID already exists
 *       500:
 *         $ref: '#/components/responses/ServerError'
 */
exports.registerTeacher = async (req, res, next) => {
  try {
    const userData = req.body;
    
    // Create user with teacher role
    const user = await userService.createUser(userData, 'teacher');
    
    // Log successful registration
    auditService.logAuthEvent('register', {
      userId: user.id,
      email: user.email,
      success: true,
      ipAddress: req.ip,
      userAgent: req.get('User-Agent')
    }).catch(err => logger.error('Failed to log registration event:', err));
    
    logger.info(`Teacher registered: ${user.email}`);
    
    return res.created(
      { userId: user.id },
      'Teacher registered successfully. Please check your email to verify your account.'
    );
  } catch (error) {
    // Log failed registration attempt
    if (req.body && req.body.email) {
      auditService.logAuthEvent('register', {
        email: req.body.email,
        success: false,
        ipAddress: req.ip,
        userAgent: req.get('User-Agent'),
        reason: error.message
      }).catch(err => logger.error('Failed to log registration failure:', err));
    }
    
    logger.error('Teacher registration error:', error);
    next(error);
  }
};

/**
 * @swagger
 * /auth/register/admin:
 *   post:
 *     summary: Register a new admin (admin only)
 *     tags: [Authentication]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - email
 *               - password
 *               - identifier
 *               - firstName
 *               - lastName
 *             properties:
 *               email:
 *                 type: string
 *                 format: email
 *               password:
 *                 type: string
 *                 minLength: 6
 *               identifier:
 *                 type: string
 *               firstName:
 *                 type: string
 *               lastName:
 *                 type: string
 *               department:
 *                 type: string
 *               position:
 *                 type: string
 *               accessLevel:
 *                 type: integer
 *                 minimum: 1
 *                 maximum: 10
 *     responses:
 *       201:
 *         description: Admin registered successfully
 *       400:
 *         $ref: '#/components/responses/ValidationError'
 *       401:
 *         $ref: '#/components/responses/UnauthorizedError'
 *       403:
 *         $ref: '#/components/responses/ForbiddenError'
 *       409:
 *         description: User with this email or admin ID already exists
 *       500:
 *         $ref: '#/components/responses/ServerError'
 */
exports.registerAdmin = async (req, res, next) => {
  try {
    // Check if the request is coming from an admin
    if (!req.user || req.user.role !== 'admin') {
      // Log unauthorized attempt to create admin
      auditService.logSecurityEvent('unauthorized_admin_creation', {
        userId: req.user ? req.user.id : null,
        action: 'create',
        resource: 'admin',
        ipAddress: req.ip,
        userAgent: req.get('User-Agent'),
        success: false
      }).catch(err => logger.error('Failed to log unauthorized admin creation:', err));
      
      return next(createError(403, 'Only administrators can register new admins'));
    }
    
    const userData = req.body;
    
    // Create user with admin role
    const user = await userService.createUser(userData, 'admin');
    
    // Log successful admin creation
    auditService.logPermissionChange({
      performedBy: req.user.id,
      targetUserId: user.id,
      previousRole: null,
      newRole: 'admin',
      ipAddress: req.ip,
      success: true
    }).catch(err => logger.error('Failed to log admin creation:', err));
    
    logger.info(`Admin registered by user ${req.user.id}: ${user.email}`);
    
    return res.created(
      { userId: user.id },
      'Admin registered successfully'
    );
  } catch (error) {
    // Log failed admin creation
    if (req.body && req.body.email) {
      auditService.logAuthEvent('register_admin', {
        userId: req.user ? req.user.id : null,
        email: req.body.email,
        success: false,
        ipAddress: req.ip,
        userAgent: req.get('User-Agent'),
        reason: error.message
      }).catch(err => logger.error('Failed to log admin registration failure:', err));
    }
    
    logger.error('Admin registration error:', error);
    next(error);
  }
};

/**
 * @swagger
 * /auth/login:
 *   post:
 *     summary: Authenticate a user and get tokens
 *     tags: [Authentication]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - email
 *               - password
 *             properties:
 *               email:
 *                 type: string
 *                 format: email
 *               password:
 *                 type: string
 *     responses:
 *       200:
 *         description: Login successful
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 message:
 *                   type: string
 *                   example: Login successful
 *                 data:
 *                   type: object
 *                   properties:
 *                     accessToken:
 *                       type: string
 *                     refreshToken:
 *                       type: string
 *                     expiresIn:
 *                       type: string
 *                       example: 1d
 *                     user:
 *                       $ref: '#/components/schemas/User'
 *       400:
 *         $ref: '#/components/responses/ValidationError'
 *       401:
 *         description: Invalid credentials
 *       500:
 *         $ref: '#/components/responses/ServerError'
 */
exports.login = async (req, res, next) => {
  try {
    const { email, password } = req.body;
    
    // Find user by email
    let user;
    try {
      user = await userService.getUserByEmail(email);
    } catch (error) {
      if (error.statusCode === 404) {
        // Don't reveal that the email doesn't exist for security reasons
        
        // Track login failure for progressive rate limiting
        if (req.trackFailure) {
          req.trackFailure(true);
        }
        
        // Log failed login attempt
        auditService.logAuthEvent('login', {
          email,
          success: false,
          ipAddress: req.ip,
          userAgent: req.get('User-Agent'),
          reason: 'User not found'
        }).catch(err => logger.error('Failed to log login failure:', err));
        
        return next(createError(401, 'Invalid credentials'));
      }
      throw error;
    }
    
    // Check if user is active
    if (!user.is_active) {
      // Log login attempt to inactive account
      auditService.logAuthEvent('login', {
        userId: user.id,
        email,
        success: false,
        ipAddress: req.ip,
        userAgent: req.get('User-Agent'),
        reason: 'Account inactive'
      }).catch(err => logger.error('Failed to log login failure:', err));
      
      return next(createError(401, 'This account has been deactivated'));
    }
    
    // Check if account is locked
    if (user.account_status === 'locked') {
      // Log login attempt to locked account
      auditService.logAuthEvent('login', {
        userId: user.id,
        email,
        success: false,
        ipAddress: req.ip,
        userAgent: req.get('User-Agent'),
        reason: 'Account locked'
      }).catch(err => logger.error('Failed to log login failure:', err));
      
      return next(createError(401, 'This account has been locked due to multiple failed login attempts. Please reset your password or contact an administrator.'));
    }
    
    // Verify password
    const isValidPassword = await passwordService.verify(password, user.password);
    
    if (!isValidPassword) {
      // Track login failure for progressive rate limiting
      if (req.trackFailure) {
        req.trackFailure(true);
      }
      
      // Increment failed login attempts
      const failedAttempts = (user.failed_login_attempts || 0) + 1;
      const updateData = {
        failed_login_attempts: failedAttempts,
        last_failed_login: new Date()
      };
      
      // Lock account after 5 consecutive failed attempts
      if (failedAttempts >= 5) {
        updateData.account_status = 'locked';
      }
      
      // Update user record
      await pool.query(
        'UPDATE users SET ? WHERE id = ?',
        [updateData, user.id]
      );
      
      // Log failed login attempt
      auditService.logAuthEvent('login', {
        userId: user.id,
        email,
        success: false,
        ipAddress: req.ip,
        userAgent: req.get('User-Agent'),
        reason: 'Invalid password',
        details: { failedAttempts }
      }).catch(err => logger.error('Failed to log login failure:', err));
      
      return next(createError(401, 'Invalid credentials'));
    }
    
    // Track successful login for progressive rate limiting
    if (req.trackFailure) {
      req.trackFailure(false);
    }
    
    // Reset failed login attempts on successful login
    if (user.failed_login_attempts > 0) {
      await pool.query(
        'UPDATE users SET failed_login_attempts = 0, last_failed_login = NULL WHERE id = ?',
        [user.id]
      );
    }
    
    // Generate tokens
    const tokens = tokenService.generateTokens(user);
    
    // Store refresh token in database
    await tokenService.storeRefreshToken(user.id, tokens.refreshToken);
    
    // Update last login time
    await pool.query(
      'UPDATE users SET last_login = NOW() WHERE id = ?',
      [user.id]
    );
    
    // Log successful login
    auditService.logAuthEvent('login', {
      userId: user.id,
      email,
      success: true,
      ipAddress: req.ip,
      userAgent: req.get('User-Agent')
    }).catch(err => logger.error('Failed to log successful login:', err));
    
    // Remove password from user object
    delete user.password;
    
    logger.info(`User logged in: ${user.email}`);
    
    return res.success(
      {
        ...tokens,
        user: {
          id: user.id,
          email: user.email,
          role: user.role,
          firstName: user.first_name,
          lastName: user.last_name,
          identifier: user.identifier,
          profileImage: user.profile_image
        }
      },
      'Login successful'
    );
  } catch (error) {
    logger.error('Login error:', error);
    next(error);
  }
};

/**
 * @swagger
 * /auth/refresh-token:
 *   post:
 *     summary: Refresh access token using refresh token
 *     tags: [Authentication]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - refreshToken
 *             properties:
 *               refreshToken:
 *                 type: string
 *     responses:
 *       200:
 *         description: Token refreshed successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 message:
 *                   type: string
 *                   example: Token refreshed successfully
 *                 data:
 *                   type: object
 *                   properties:
 *                     accessToken:
 *                       type: string
 *                     refreshToken:
 *                       type: string
 *                     expiresIn:
 *                       type: string
 *                       example: 1d
 *       400:
 *         description: Invalid refresh token
 *       401:
 *         description: Refresh token expired
 *       500:
 *         $ref: '#/components/responses/ServerError'
 */
exports.refreshToken = async (req, res, next) => {
  try {
    const { refreshToken } = req.body;
    
    if (!refreshToken) {
      return next(createError(400, 'Refresh token is required'));
    }
    
    // Verify and get refresh token
    let tokenData;
    try {
      tokenData = await tokenService.verifyRefreshToken(refreshToken);
    } catch (error) {
      // Log token refresh failure
      auditService.logAuthEvent('token_refresh', {
        success: false,
        ipAddress: req.ip,
        userAgent: req.get('User-Agent'),
        reason: error.message
      }).catch(err => logger.error('Failed to log token refresh failure:', err));
      
      return next(error);
    }
    
    // Get user data
    const user = await userService.getUserById(tokenData.decoded.id);
    
    // Check if user is still active
    if (!user.is_active || user.account_status !== 'active') {
      // Revoke all user tokens if account is no longer active
      await tokenService.revokeAllUserTokens(user.id);
      
      // Log token refresh failure
      auditService.logAuthEvent('token_refresh', {
        userId: user.id,
        success: false,
        ipAddress: req.ip,
        userAgent: req.get('User-Agent'),
        reason: 'Account not active'
      }).catch(err => logger.error('Failed to log token refresh failure:', err));
      
      return next(createError(401, 'Your account is no longer active'));
    }
    
    // Generate new tokens
    const newTokens = tokenService.generateTokens(user);
    
    // Revoke old refresh token
    await tokenService.revokeRefreshToken(refreshToken);
    
    // Store new refresh token
    await tokenService.storeRefreshToken(user.id, newTokens.refreshToken);
    
    // Log successful token refresh
    auditService.logAuthEvent('token_refresh', {
      userId: user.id,
      success: true,
      ipAddress: req.ip,
      userAgent: req.get('User-Agent')
    }).catch(err => logger.error('Failed to log token refresh:', err));
    
    logger.info(`Token refreshed for user: ${user.email}`);
    
    return res.success(
      newTokens,
      'Token refreshed successfully'
    );
  } catch (error) {
    logger.error('Token refresh error:', error);
    next(error);
  }
};

/**
 * @swagger
 * /auth/logout:
 *   post:
 *     summary: Logout a user by invalidating refresh token
 *     tags: [Authentication]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - refreshToken
 *             properties:
 *               refreshToken:
 *                 type: string
 *     responses:
 *       200:
 *         description: Logout successful
 *       400:
 *         description: Refresh token is required
 *       401:
 *         $ref: '#/components/responses/UnauthorizedError'
 *       500:
 *         $ref: '#/components/responses/ServerError'
 */
exports.logout = async (req, res, next) => {
  try {
    const { refreshToken } = req.body;
    
    if (!refreshToken) {
      return next(createError(400, 'Refresh token is required'));
    }
    
    // Revoke refresh token
    await tokenService.revokeRefreshToken(refreshToken);
    
    // Log logout event
    auditService.logAuthEvent('logout', {
      userId: req.user ? req.user.id : null,
      success: true,
      ipAddress: req.ip,
      userAgent: req.get('User-Agent')
    }).catch(err => logger.error('Failed to log logout:', err));
    
    logger.info(`User logged out: ${req.user ? req.user.email : 'unknown'}`);
    
    return res.success(
      null,
      'Logout successful'
    );
  } catch (error) {
    logger.error('Logout error:', error);
    next(error);
  }
};

/**
 * @swagger
 * /auth/logout-all:
 *   post:
 *     summary: Logout from all devices by invalidating all refresh tokens
 *     tags: [Authentication]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Logout from all devices successful
 *       401:
 *         $ref: '#/components/responses/UnauthorizedError'
 *       500:
 *         $ref: '#/components/responses/ServerError'
 */
exports.logoutAll = async (req, res, next) => {
  try {
    // Revoke all refresh tokens for the user
    await tokenService.revokeAllUserTokens(req.user.id);
    
    // Log logout from all devices event
    auditService.logAuthEvent('logout_all', {
      userId: req.user.id,
      success: true,
      ipAddress: req.ip,
      userAgent: req.get('User-Agent')
    }).catch(err => logger.error('Failed to log logout from all devices:', err));
    
    logger.info(`User logged out from all devices: ${req.user.email}`);
    
    return res.success(
      null,
      'Logged out from all devices successfully'
    );
  } catch (error) {
    logger.error('Logout from all devices error:', error);
    next(error);
  }
};

/**
 * @swagger
 * /auth/forgot-password:
 *   post:
 *     summary: Request a password reset link
 *     tags: [Authentication]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - email
 *             properties:
 *               email:
 *                 type: string
 *                 format: email
 *     responses:
 *       200:
 *         description: Password reset email sent
 *       400:
 *         $ref: '#/components/responses/ValidationError'
 *       404:
 *         description: User not found
 *       500:
 *         $ref: '#/components/responses/ServerError'
 */
exports.forgotPassword = async (req, res, next) => {
  try {
    const { email } = req.body;
    
    // Find user by email
    let user;
    try {
      user = await userService.getUserByEmail(email);
    } catch (error) {
      if (error.statusCode === 404) {
        // Don't reveal that the email doesn't exist for security reasons
        
        // Log failed password reset request
        auditService.logAuthEvent('forgot_password', {
          email,
          success: false,
          ipAddress: req.ip,
          userAgent: req.get('User-Agent'),
          reason: 'User not found'
        }).catch(err => logger.error('Failed to log password reset request:', err));
        
        return res.success(
          null,
          'If your email exists in our database, you will receive a password reset link'
        );
      }
      throw error;
    }
    
    // Generate reset token
    const resetToken = passwordService.generateResetToken();
    
    // Store token in database
    await passwordService.storeResetToken(user.id, resetToken);
    
    // Log successful password reset request
    auditService.logAuthEvent('forgot_password', {
      userId: user.id,
      email,
      success: true,
      ipAddress: req.ip,
      userAgent: req.get('User-Agent')
    }).catch(err => logger.error('Failed to log password reset request:', err));
    
    // In a real application, send email with reset link
    // For now, just log it
    logger.info(`Password reset requested for ${email}. Reset token: ${resetToken}`);
    
    return res.success(
      null,
      'If your email exists in our database, you will receive a password reset link'
    );
  } catch (error) {
    logger.error('Forgot password error:', error);
    next(error);
  }
};

/**
 * @swagger
 * /auth/reset-password:
 *   post:
 *     summary: Reset user password using reset token
 *     tags: [Authentication]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - token
 *               - newPassword
 *               - confirmPassword
 *             properties:
 *               token:
 *                 type: string
 *               newPassword:
 *                 type: string
 *                 minLength: 6
 *               confirmPassword:
 *                 type: string
 *     responses:
 *       200:
 *         description: Password reset successful
 *       400:
 *         $ref: '#/components/responses/ValidationError'
 *       404:
 *         description: Invalid or expired reset token
 *       500:
 *         $ref: '#/components/responses/ServerError'
 */
exports.resetPassword = async (req, res, next) => {
  try {
    const { token, newPassword } = req.body;
    
    // Verify reset token
    let resetToken;
    try {
      resetToken = await passwordService.verifyResetToken(token);
    } catch (error) {
      // Log failed password reset
      auditService.logAuthEvent('reset_password', {
        success: false,
        ipAddress: req.ip,
        userAgent: req.get('User-Agent'),
        reason: 'Invalid or expired token'
      }).catch(err => logger.error('Failed to log password reset failure:', err));
      
      return next(error);
    }
    
    // Update user password
    await userService.updatePassword(resetToken.user_id, newPassword);
    
    // Delete used token
    await passwordService.deleteResetToken(token);
    
    // Delete all refresh tokens for the user to force re-login with new password
    await tokenService.revokeAllUserTokens(resetToken.user_id);
    
    // If account was locked due to failed login attempts, unlock it
    await pool.query(
      `UPDATE users SET 
        account_status = 'active', 
        failed_login_attempts = 0, 
        last_failed_login = NULL,
        password_changed_at = NOW(),
        require_password_change = FALSE
       WHERE id = ?`,
      [resetToken.user_id]
    );
    
    // Log successful password reset
    auditService.logAuthEvent('reset_password', {
      userId: resetToken.user_id,
      success: true,
      ipAddress: req.ip,
      userAgent: req.get('User-Agent')
    }).catch(err => logger.error('Failed to log password reset:', err));
    
    logger.info(`Password reset successful for user ID: ${resetToken.user_id}`);
    
    return res.success(
      null,
      'Password reset successful. Please login with your new password.'
    );
  } catch (error) {
    logger.error('Reset password error:', error);
    next(error);
  }
};

/**
 * @swagger
 * /auth/change-password:
 *   post:
 *     summary: Change user password (requires authentication)
 *     tags: [Authentication]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - currentPassword
 *               - newPassword
 *               - confirmPassword
 *             properties:
 *               currentPassword:
 *                 type: string
 *               newPassword:
 *                 type: string
 *                 minLength: 6
 *               confirmPassword:
 *                 type: string
 *     responses:
 *       200:
 *         description: Password changed successfully
 *       400:
 *         $ref: '#/components/responses/ValidationError'
 *       401:
 *         description: Current password is incorrect
 *       500:
 *         $ref: '#/components/responses/ServerError'
 */
exports.changePassword = async (req, res, next) => {
  try {
    const { currentPassword, newPassword } = req.body;
    
    // Get user with password
    const user = await userService.getUserByEmail(req.user.email);
    
    // Verify current password
    const isValidPassword = await passwordService.verify(currentPassword, user.password);
    
    if (!isValidPassword) {
      // Log failed password change attempt
      auditService.logAuthEvent('change_password', {
        userId: user.id,
        success: false,
        ipAddress: req.ip,
        userAgent: req.get('User-Agent'),
        reason: 'Current password incorrect'
      }).catch(err => logger.error('Failed to log password change failure:', err));
      
      return next(createError(401, 'Current password is incorrect'));
    }
    
    // Update password
    await userService.updatePassword(user.id, newPassword);
    
    // Update password change timestamp and reset require_password_change flag
    await pool.query(
      'UPDATE users SET password_changed_at = NOW(), require_password_change = FALSE WHERE id = ?',
      [user.id]
    );
    
    // Delete all refresh tokens for the user to force re-login with new password
    await tokenService.revokeAllUserTokens(user.id);
    
    // Log successful password change
    auditService.logAuthEvent('change_password', {
      userId: user.id,
      success: true,
      ipAddress: req.ip,
      userAgent: req.get('User-Agent')
    }).catch(err => logger.error('Failed to log password change:', err));
    
    logger.info(`Password changed for user: ${user.email}`);
    
    return res.success(
      null,
      'Password changed successfully. Please login again with your new password.'
    );
  } catch (error) {
    logger.error('Change password error:', error);
    next(error);
  }
};

/**
 * @swagger
 * /auth/verify-email:
 *   post:
 *     summary: Verify user email address
 *     tags: [Authentication]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - token
 *             properties:
 *               token:
 *                 type: string
 *     responses:
 *       200:
 *         description: Email verified successfully
 *       400:
 *         $ref: '#/components/responses/ValidationError'
 *       404:
 *         description: Invalid or expired verification token
 *       500:
 *         $ref: '#/components/responses/ServerError'
 */
exports.verifyEmail = async (req, res, next) => {
  try {
    const { token } = req.body;
    
    // Find verification token in database
    const [verificationTokens] = await pool.query(
      'SELECT * FROM email_verification WHERE verification_token = ? AND expires_at > NOW()',
      [token]
    );
    
    if (verificationTokens.length === 0) {
      return next(createError(404, 'Invalid or expired verification token'));
    }
    
    const verificationToken = verificationTokens[0];
    
    // Update user email_verified status
    await pool.query(
      'UPDATE users SET email_verified = TRUE WHERE id = ?',
      [verificationToken.user_id]
    );
    
    // Delete used token
    await pool.query(
      'DELETE FROM email_verification WHERE verification_token = ?',
      [token]
    );
    
    // Log successful email verification
    auditService.logAuthEvent('email_verification', {
      userId: verificationToken.user_id,
      success: true,
      ipAddress: req.ip,
      userAgent: req.get('User-Agent')
    }).catch(err => logger.error('Failed to log email verification:', err));
    
    logger.info(`Email verified for user ID: ${verificationToken.user_id}`);
    
    return res.success(
      null,
      'Email verified successfully. You can now login to your account.'
    );
  } catch (error) {
    logger.error('Email verification error:', error);
    next(error);
  }
};

/**
 * @swagger
 * /auth/resend-verification:
 *   post:
 *     summary: Resend email verification link
 *     tags: [Authentication]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - email
 *             properties:
 *               email:
 *                 type: string
 *                 format: email
 *     responses:
 *       200:
 *         description: Verification email sent
 *       400:
 *         $ref: '#/components/responses/ValidationError'
 *       500:
 *         $ref: '#/components/responses/ServerError'
 */
exports.resendVerification = async (req, res, next) => {
  try {
    const { email } = req.body;
    
    // Find user by email
    let user;
    try {
      user = await userService.getUserByEmail(email);
    } catch (error) {
      if (error.statusCode === 404) {
        // Don't reveal that the email doesn't exist for security reasons
        return res.success(
          null,
          'If your email exists in our database, you will receive a verification link'
        );
      }
      throw error;
    }
    
    // Check if email is already verified
    if (user.email_verified) {
      return res.success(
        null,
        'Your email is already verified. You can login to your account.'
      );
    }
    
    // Generate verification token
    const verificationToken = crypto.randomBytes(32).toString('hex');
    
    // Set expiry (24 hours from now)
    const expiry = new Date();
    expiry.setHours(expiry.getHours() + 24);
    
    // Delete any existing verification tokens for this user
    await pool.query(
      'DELETE FROM email_verification WHERE user_id = ?',
      [user.id]
    );
    
    // Store new token in database
    await pool.query(
      'INSERT INTO email_verification (user_id, verification_token, expires_at) VALUES (?, ?, ?)',
      [user.id, verificationToken, expiry]
    );
    
    // Log verification email sent
    auditService.logAuthEvent('verification_email_sent', {
      userId: user.id,
      email: user.email,
      success: true,
      ipAddress: req.ip,
      userAgent: req.get('User-Agent')
    }).catch(err => logger.error('Failed to log verification email sent:', err));
    
    // In a real application, send email with verification link
    // For now, just log it
    logger.info(`Email verification requested for ${email}. Verification token: ${verificationToken}`);
    
    return res.success(
      null,
      'Verification email sent. Please check your inbox.'
    );
  } catch (error) {
    logger.error('Resend verification error:', error);
    next(error);
  }
};

/**
 * @swagger
 * /auth/user:
 *   get:
 *     summary: Get current user information
 *     tags: [Authentication]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Current user information
 *       401:
 *         $ref: '#/components/responses/UnauthorizedError'
 *       500:
 *         $ref: '#/components/responses/ServerError'
 */
exports.getCurrentUser = async (req, res, next) => {
  try {
    // Get user details from database
    const user = await userService.getUserById(req.user.id);
    
    // Get user permissions
    const permissions = permissionService.getRolePermissions(user.role);
    
    return res.success({
      id: user.id,
      email: user.email,
      role: user.role,
      firstName: user.first_name,
      lastName: user.last_name,
      identifier: user.identifier,
      profileImage: user.profile_image,
      isActive: user.is_active,
      emailVerified: user.email_verified,
      lastLogin: user.last_login,
      profile: user.profile,
      permissions
    }, 'User information retrieved successfully');
  } catch (error) {
    logger.error('Get current user error:', error);
    next(error);
  }
};

/**
 * @swagger
 * /auth/active-sessions:
 *   get:
 *     summary: Get all active sessions for current user
 *     tags: [Authentication]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: List of active sessions
 *       401:
 *         $ref: '#/components/responses/UnauthorizedError'
 *       500:
 *         $ref: '#/components/responses/ServerError'
 */
exports.getActiveSessions = async (req, res, next) => {
  try {
    // Get all active sessions for the user
    const [sessions] = await pool.query(
      `SELECT id, ip_address, user_agent, last_activity, created_at
       FROM user_sessions
       WHERE user_id = ? AND expires_at > NOW()
       ORDER BY last_activity DESC`,
      [req.user.id]
    );
    
    return res.success(
      sessions,
      'Active sessions retrieved successfully'
    );
  } catch (error) {
    logger.error('Get active sessions error:', error);
    next(error);
  }
};

/**
 * @swagger
 * /auth/terminate-session/{sessionId}:
 *   delete:
 *     summary: Terminate a specific session
 *     tags: [Authentication]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: sessionId
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID of the session to terminate
 *     responses:
 *       200:
 *         description: Session terminated successfully
 *       401:
 *         $ref: '#/components/responses/UnauthorizedError'
 *       403:
 *         description: Not authorized to terminate this session
 *       404:
 *         description: Session not found
 *       500:
 *         $ref: '#/components/responses/ServerError'
 */
exports.terminateSession = async (req, res, next) => {
  try {
    const { sessionId } = req.params;
    
    // Check if session exists and belongs to the user
    const [sessions] = await pool.query(
      'SELECT * FROM user_sessions WHERE id = ?',
      [sessionId]
    );
    
    if (sessions.length === 0) {
      return next(createError(404, 'Session not found'));
    }
    
    const session = sessions[0];
    
    // Check if session belongs to the user or if user is admin
    if (session.user_id !== req.user.id && req.user.role !== 'admin') {
      // Log unauthorized session termination attempt
      auditService.logSecurityEvent('unauthorized_session_termination', {
        userId: req.user.id,
        targetId: session.user_id,
        action: 'terminate',
        resource: `session/${sessionId}`,
        ipAddress: req.ip,
        userAgent: req.get('User-Agent'),
        success: false
      }).catch(err => logger.error('Failed to log unauthorized session termination:', err));
      
      return next(createError(403, 'You are not authorized to terminate this session'));
    }
    
    // Delete session
    await pool.query(
      'DELETE FROM user_sessions WHERE id = ?',
      [sessionId]
    );
    
    // Log session termination
    auditService.logSecurityEvent('session_terminated', {
      userId: req.user.id,
      targetId: session.user_id,
      action: 'terminate',
      resource: `session/${sessionId}`,
      ipAddress: req.ip,
      userAgent: req.get('User-Agent'),
      success: true
    }).catch(err => logger.error('Failed to log session termination:', err));
    
    return res.success(
      null,
      'Session terminated successfully'
    );
  } catch (error) {
    logger.error('Terminate session error:', error);
    next(error);
  }
};

/**
 * @swagger
 * /auth/security-settings:
 *   get:
 *     summary: Get user security settings
 *     tags: [Authentication]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: User security settings
 *       401:
 *         $ref: '#/components/responses/UnauthorizedError'
 *       500:
 *         $ref: '#/components/responses/ServerError'
 */
exports.getSecuritySettings = async (req, res, next) => {
  try {
    // Get security settings for the user
    const [settings] = await pool.query(
      'SELECT * FROM user_security_settings WHERE user_id = ?',
      [req.user.id]
    );
    
    // If no settings found, return default settings
    if (settings.length === 0) {
      return res.success({
        twoFactorEnabled: false,
        twoFactorMethod: null,
        notificationOnLogin: false,
        allowedIps: null,
        sessionTimeoutMinutes: 60
      }, 'Security settings retrieved successfully');
    }
    
    const userSettings = settings[0];
    
    return res.success({
      twoFactorEnabled: userSettings.two_factor_enabled === 1,
      twoFactorMethod: userSettings.two_factor_method,
      notificationOnLogin: userSettings.notification_on_login === 1,
      allowedIps: userSettings.allowed_ips,
      sessionTimeoutMinutes: userSettings.session_timeout_minutes
    }, 'Security settings retrieved successfully');
  } catch (error) {
    logger.error('Get security settings error:', error);
    next(error);
  }
};

/**
 * @swagger
 * /auth/security-settings:
 *   put:
 *     summary: Update user security settings
 *     tags: [Authentication]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               twoFactorEnabled:
 *                 type: boolean
 *               twoFactorMethod:
 *                 type: string
 *                 enum: [app, email, sms]
 *               notificationOnLogin:
 *                 type: boolean
 *               allowedIps:
 *                 type: string
 *               sessionTimeoutMinutes:
 *                 type: integer
 *                 minimum: 15
 *                 maximum: 1440
 *     responses:
 *       200:
 *         description: Security settings updated successfully
 *       400:
 *         $ref: '#/components/responses/ValidationError'
 *       401:
 *         $ref: '#/components/responses/UnauthorizedError'
 *       500:
 *         $ref: '#/components/responses/ServerError'
 */
exports.updateSecuritySettings = async (req, res, next) => {
  try {
    const { 
      twoFactorEnabled, 
      twoFactorMethod, 
      notificationOnLogin, 
      allowedIps, 
      sessionTimeoutMinutes 
    } = req.body;
    
    // Validate session timeout
    if (sessionTimeoutMinutes !== undefined && 
        (sessionTimeoutMinutes < 15 || sessionTimeoutMinutes > 1440)) {
      return next(createError(400, 'Session timeout must be between 15 and 1440 minutes'));
    }
    
    // Check if settings exist for the user
    const [existingSettings] = await pool.query(
      'SELECT * FROM user_security_settings WHERE user_id = ?',
      [req.user.id]
    );
    
    const settings = {
      two_factor_enabled: twoFactorEnabled !== undefined ? twoFactorEnabled : undefined,
      two_factor_method: twoFactorMethod,
      notification_on_login: notificationOnLogin !== undefined ? notificationOnLogin : undefined,
      allowed_ips: allowedIps,
      session_timeout_minutes: sessionTimeoutMinutes
    };
    
    // Filter out undefined values
    Object.keys(settings).forEach(key => 
      settings[key] === undefined && delete settings[key]
    );
    
    if (existingSettings.length === 0) {
      // Create new settings
      await pool.query(
        'INSERT INTO user_security_settings (user_id, two_factor_enabled, two_factor_method, notification_on_login, allowed_ips, session_timeout_minutes) VALUES (?, ?, ?, ?, ?, ?)',
        [
          req.user.id, 
          settings.two_factor_enabled !== undefined ? settings.two_factor_enabled : false,
          settings.two_factor_method || null,
          settings.notification_on_login !== undefined ? settings.notification_on_login : false,
          settings.allowed_ips || null,
          settings.session_timeout_minutes || 60
        ]
      );
    } else {
      // Update existing settings
      await pool.query(
        'UPDATE user_security_settings SET ? WHERE user_id = ?',
        [settings, req.user.id]
      );
    }
    
    // Log security settings update
    auditService.logSecurityEvent('security_settings_updated', {
      userId: req.user.id,
      action: 'update',
      resource: 'security_settings',
      ipAddress: req.ip,
      userAgent: req.get('User-Agent'),
      success: true,
      details: settings
    }).catch(err => logger.error('Failed to log security settings update:', err));
    
    return res.success(
      null,
      'Security settings updated successfully'
    );
  } catch (error) {
    logger.error('Update security settings error:', error);
    next(error);
  }
};

module.exports = exports;
